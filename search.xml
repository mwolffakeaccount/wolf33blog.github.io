<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【洛谷】P1579 哥德巴赫猜想（升级版）]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1579-%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线性筛经典题 题目大意给一个数n，输出3个质数，使这三个质数之和为n 思路直接线性筛后用prime数组枚举。 算法简述 线性筛，就是上图的算法，代码中vis数组为标注此数是否被访问，而prime数组用于保存质数。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;time.h&gt;using namespace std;int n;int vis[20010],prime[5010];int cnt;void pri(int size)&#123; for(int i=2;i&lt;=size;i++) &#123; if(!vis[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;size;j++) &#123; vis[i*prime[j]]=true; if(i*prime[j]==0) break; &#125; &#125;&#125;bool check(int x)&#123; for(int i=2;i*i&lt;=x;i++) if(x%i==0) return false; return true;&#125;int main()&#123; scanf("%d", &amp;n); pri(n); for(int i=1;i&lt;=cnt;i++) for(int j=i;j&lt;=cnt;j++) if(check(n-prime[i]-prime[j]) &amp;&amp; (n-prime[i]-prime[j])&gt;0 &amp;&amp; prime[i]&gt;0 &amp;&amp; prime[j]&gt;0) &#123; printf("%d %d %d", prime[i],prime[j], n-prime[i]-prime[j]); return 0; &#125; return 0;&#125; check为最简单的筛素数方法，而pri为线性筛素数筛法 鸣谢本文动图来自百度]]></content>
      <tags>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Before Reading]]></title>
    <url>%2FTop%2F</url>
    <content type="text"><![CDATA[在阅读以下内容前请先阅览此文，大概需要1分钟 使用说明：不建议手机党使用（因为我也没有看过手机的版本），电脑使用更佳。 电脑使用由于技术原因，建议缩小页面百分比至90% 左下角的地球为访客数量统计，如果不合适可以把鼠标移至地球上，然后缩小。 如果有任何bug或问题，请洛谷私信uid:101153 鸣谢：本站为个人站。 本站的建成感谢 Venus的帮助和答疑。 TBC.]]></content>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】P1217 回文质数]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1217%20%E5%9B%9E%E6%96%87%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一道很有意思的题目 题目大意：给一个区间，求出这个区间中既是回文数，又是质数的数。 等等，这关标签里面的深搜什么事？ 待我慢慢道来…… 首先，看到这个题目的明显感觉：先线性筛之后再判断回文不就行了 紧接着发现：这是1亿的数组？线性筛存得下吗？ 计算发现：好像是存的下的，大概90MB左右。 写出了一个小函数 1234567891011121314void check()&#123; for(int i=2;i&lt;=maxn;i++) &#123; if(!vis[i]) pri[++pri[0]]=i; for(int j=1;j&lt;=pri[0]&amp;&amp;i*pri[j]&lt;=maxn;j++) &#123; vis[i*pri[j]]=1; if(i%pri[j]==0) break; &#125; &#125;&#125; 复杂度O(nlogn)，应该可以用。 然后判断回文数： 12345678910111213bool check_prime(int x)&#123; int y=x,num=0; while(y!=0) &#123; num=num*10+y%10; y/=10; &#125; if(num==x) return 1; else return 0;&#125; 这里也很容易理解，把x翻转过来，如果x=num就表示是回文 第一次提交： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;using namespace std;int l,r;bool vis[1000010];int pri[1000010];void check()&#123; for(int i=2;i&lt;=r;i++) &#123; if(!vis[i]) pri[++pri[0]]=i; for(int j=1;j&lt;=pri[0] &amp;&amp; i*pri[j]&lt;=r;j++) &#123; vis[i*pri[j]]=1; if(i%pri[j]==0) break; &#125; &#125;&#125;bool check_hw(int x)&#123; int y=x,num=0; while(y!=0) &#123; num=num*10+y%10; y/=10; &#125; if(num==x) return 1; else return 0;&#125;int main()&#123; scanf("%d%d", &amp;l, &amp;r); check(); for(int i=1;i&lt;=1000100;i++) if(pri[i]&lt;=r &amp;&amp; pri[i]&gt;=l &amp;&amp; check_hw(pri[i])) printf("%d\n", pri[i]); return 0;&#125; re了四个点（提交记录) TBC. 文献：回文质数题解1 回文质数题解2 回文质数题解3 声明：一道经典的线性筛题目 线性筛这里指“埃拉托斯特尼筛法”，是一种简单的鉴定质数的方法，因为其复杂度为线性复杂度而得名。 可以以下面的动图来看;]]></content>
      <tags>
        <tag>高性能</tag>
        <tag>深搜</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷】P1598 垂直柱状图]]></title>
    <url>%2F%E3%80%90%E6%B4%9B%E8%B0%B7%E3%80%91P1598%20%E5%9E%82%E7%9B%B4%E6%9F%B1%E7%8A%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一道简单的模拟题，但我还是调了30分钟。 题目链接 好像是一道模拟题 这题怎么是普及-难度但是我调了半个多小时啊啊啊啊啊！ 第一次调试： 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;cstring&gt;char a[10][110];int cnt[110];int ans;int main()&#123; for(int i=1;i&lt;=4;i++) &#123; scanf("%s", a[i]+1); int n=strlen(a[i]+1); for(int j=1;j&lt;=n;j++) cnt[a[i][j]-'A']++; &#125; for(int i='A';i&lt;='Z';i++) if(cnt[i-'A']&gt;ans) ans=cnt[i-'A'];// for(int i='A';i&lt;='Z';i++)// printf("%d ", cnt[i-'A']); for(int i=ans;i&gt;=1;i--) &#123; for(int j='A';j&lt;='Z';j++) &#123; if(cnt[j-'A'&gt;=i]) printf("*"); else printf(" "); printf(" "); &#125; printf("\n"); &#125; printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"); return 0;&#125; 输入： THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG.THIS IS AN EXAMPLE TO TEST FOR YOURHISTOGRAM PROGRAM.HELLO! 输出： 0 1 1 0 1 1 0 1 1 0 1 0 0 1 2 0 1 1 0 1 1 0 1 1 0 0 ？？？这是怎么回事？ 简单看了一下，好像没有问题。开始逐步查看，先查看a[i]的输入 emmmm好像是scanf(“%s”, a[i]+1)的原因！ 使用gets输入，改为gets(a[i]+1) 那么为什么改成这个就是对的了呢？ gets可以读入空格，但是scanf不能，所以导致这里只输入了第一个单词，错误。 开始查看正确考试的输出 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;cstring&gt;char a[10][110];int cnt[110];int ans;int main()&#123; for(int i=1;i&lt;=4;i++) &#123; gets(a[i]+1); int n=strlen(a[i]+1); for(int j=1;j&lt;=n;j++) cnt[a[i][j]-'A']++; &#125; for(int i='A';i&lt;='Z';i++) if(cnt[i-'A']&gt;ans) ans=cnt[i-'A'];// for(int i='A';i&lt;='Z';i++)// printf("%d ", cnt[i-'A']); for(int i=ans;i&gt;=1;i--) &#123; for(int j='A';j&lt;='Z';j++) &#123; if(cnt[j-'A'&gt;=i]) printf("*"); else printf(" "); printf(" "); &#125; printf("\n"); &#125; printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"); return 0;&#125; 结果就凉了，输出是ABCDEFGHIJKLMNOPQRSTUVWXYZ全部一样 那么就是20行到32行的问题了，接着查看。 注意看24行： 1if(cnt[j-'A'&gt;=i]) 这括号打错了（大雾） 改为： 1if(cnt[j-'A']&gt;=i) 似乎对了，提交 正确！完结撒花（大雾） 代码一览： 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;cstring&gt;char a[10][110];int cnt[110];int ans;int main()&#123; for(int i=1;i&lt;=4;i++) &#123; gets(a[i]+1); int n=strlen(a[i]+1); for(int j=1;j&lt;=n;j++) cnt[a[i][j]-'A']++; &#125; for(int i='A';i&lt;='Z';i++) if(cnt[i-'A']&gt;ans) ans=cnt[i-'A']; for(int i=ans;i&gt;=1;i--) &#123; for(int j='A';j&lt;='Z';j++) &#123; if(cnt[j-'A']&gt;=i) printf("*"); else printf(" "); printf(" "); &#125; printf("\n"); &#125; printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"); return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2Ftest%2F</url>
    <content type="text"><![CDATA[一个小测试 二次测试这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 这是引用的内容 这是引用的内容 这是引用的内容 ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”) 简书百度 简书 列表内容 列表内容 列表内容 1.列表内容2.列表内容3.列表内容 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 create database hero; (123456789101112131415 function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```)```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
